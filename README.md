# Six-Card Solitaire 
A toy implementation of a miniaturized 6-card Klondike solitaire game (no suits, two columns, one foundation pile). 

I made this to learn how to make a card game solver and (trying to attempt to maybe one day...) make a decent user interface for interactive play. 

All coded in base R except for one library (Rmisc) to compile statistics. The script will attempt to install it if not already installed. 

# Contents

## sol6_100k.R 
Brute-force solver.
 - Plays 100,000 random games by brute-force until: it wins ("Won") or quits after either 50 illegal consecutive moves ("Unsolved") or 500 valid moves ("Timeout").
 - Report start and end states, number of valid moves and outcome for each game (Won, Unsolved or Timeout). Stores results in `sol6_100k_game_report.txt`.
 - Finds the shortest solution for each unique winnable draw. Stores results in `sol6_100k_best_solutions.txt`.

## sol6_interactive.R
A playable game interface that uses the same modules than the ones used for the solver (see subfolder `modules`). Lets you play the game in the R console.

## modules/
This folder contains functions that are essential for the above script to work.
 - deal.R (initializes a new game object and distributes cards)
 - draw.R (puts the last card on the stock pile at the bottom. I did not implement a waste pile here.)
 - mv.R (a spaghetti of nested if-else statements to move card between columns while checking for the validity of the moves.)
 - playRandom.R (creates a new game and plays it with random moves. This is the "engine" of the `sol6_100k` solver.
 - viewGameState.R (used for the interactive player to show the game object as columns of cards, which is nicer than printing the game object itself.) 

# Game definition

## Layout
 - Six cards (1,2,3,4,5,6)
 - No suits
 - Two Tableau columns (first = two cards, 2nd = two cards)
 - One Foundation pile
 - One Stock pile

## What a game looks like for R
The game's data structure is a list of integer vectors. An initialized game object looks like this:
```
# example game object (init state; cards not yet dealt)
myGame <- list(
  cards = c(1,2,3,4,5,6)   ### stock pile   
  pile = character(0)      ### foundation pile
  col1 = character(0)      ### tableau column 1
  col2 = character(0)      ### tableau column 2
)
```

## How cards are dealt
 - Cards are dealt from index 1 to 6
 - One card in Tableau column 1
 - Two cards in Tableau column 2
 - then the rest goes in the Stock pile.
 - All cards are visible

The function `deal()` in `modules/deal.R` does both initializing a game object and dealing cards.
A game object generated by `deal()` looks like this:
```
# create game object and deal cards
myGame <- deal(myGame)

# view resulting game object
myGame

###-----------------
### $cards
### [1] 2 4 5
###
### $pile
### character(0)
### 
### $col1
### [1] 1
###
### $col2
### [1] 6 3
### ---------------
```

## Rules
Rules are the same as Klondike solitaire with a few conventions and exceptions (...and much less cards):

 - The last card (highest index) in each column or pile is the face-up card.
 - Drawing a card = putting the face-up card of the Stock pile at the bottom (1,2,3 -> 3,1,2).
 - There is no waste pile.
 - One card can be moved at at time (no sequence moves).
 - Cards can be moved :
   - from the Stock pile to the Tableau's columns (but must be arranged in descending order);
   - Between columns;
   - From the stock pile to the Foundation (in ascending order);
   - From a column to the Foundation (in ascending order).
 - Cards in the Foundation cannot go back to the Tableau or the Stock pile.
 - The game is won when all cards are in the Foundation pile in ascending order (1,2,3,4,5,6).
